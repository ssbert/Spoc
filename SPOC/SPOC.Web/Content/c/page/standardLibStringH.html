<div class="standardLibStringH-block">
	<div class="n-nav-strip clearfix">
		<a href="#standardLibStdlibH" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			C 标准库 - &lt;stdlib.h&gt;
		</a>
		<a href="#standardLibTimeH" class="pull-right green">
			C 标准库 - &lt;time.h&gt;
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
	<div class="n-block n-border-b">
		<h1 class="n-h1">
			C 标准库 - <span class="green">&lt;string.h&gt;</span>
		</h1>
		<h2 class="n-h2">
			简介
		</h2>
		<p><b>string.h</b> 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。</p>
		<h2 class="n-h2">
			库变量
		</h2>
		<p>下面是头文件 string.h 中定义的变量类型：</p>
		<table>
			<thead>
				<tr><th style="width:5%">序号</th><th>变量 &amp; 描述</th></tr>
			</thead>
			<tbody>
				<tr><td>1</td><td><b>size_t </b><br>这是无符号整数类型，它是 <b>sizeof</b> 关键字的结果。</td></tr>
			</tbody>
		</table>
		<h2 class="n-h2">
			库宏
		</h2>
		<p>下面是头文件 string.h 中定义的宏：</p>
		<table>
			<thead>
				<tr><th style="width:5%">序号</th><th>宏 &amp; 描述</th></tr>
			</thead>
			<tbody>
				<tr><td>1</td><td><b>NULL</b><br>这个宏是一个空指针常量的值。</td></tr>
			</tbody>
		</table>
		<h2 class="n-h2">
			库函数
		</h2>
		<p>下面是头文件 string.h 中定义的函数：</p>
		<table>
			<thead>
				<tr><th style="width:5%">序号</th><th>函数 &amp; 描述</th></tr>
			</thead>
			<tbody>
				<tr><td>1</td><td><a href="#functionMemchr" class="n-text-line green">void *memchr(const void *str, int c, size_t n)</a><br>在参数 <i>str</i> 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr>
				<tr><td>2</td><td><a href="#functionMemcmp" class="n-text-line green">int memcmp(const void *str1, const void *str2, size_t n)</a><br>把 <i>str1</i> 和 <i>str2</i> 的前 n 个字节进行比较。</td></tr>
				<tr><td>3</td><td><a href="#functionMemcpy" class="n-text-line green">void *memcpy(void *dest, const void *src, size_t n)</a><br>从 src 复制 n 个字符到 <i>dest</i>。</td></tr>
				<tr><td>4</td><td><a href="#functionMemmove" class="n-text-line green">void *memmove(void *dest, const void *src, size_t n)</a><br>另一个用于从 <i>str2</i> 复制 n 个字符到 <i>str1</i> 的函数。</td></tr>
				<tr><td>5</td><td><a href="#functionMemset" class="n-text-line green">void *memset(void *str, int c, size_t n)</a><br>复制字符 c（一个无符号字符）到参数 <i>str</i> 所指向的字符串的前 n 个字符。</td></tr>
				<tr><td>6</td><td><a href="#functionStrcat" class="n-text-line green">char *strcat(char *dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串追加到 <i>dest</i> 所指向的字符串的结尾。</td></tr>
				<tr><td>7</td><td><a href="#functionStrncat" class="n-text-line green">char *strncat(char *dest, const char *src, size_t n)</a><br>把 <i>src</i> 所指向的字符串追加到 <i>dest</i> 所指向的字符串的结尾，直到 n 字符长度为止。</td></tr>
				<tr><td>8</td><td><a href="#functionStrchr" class="n-text-line green">char *strchr(const char *str, int c)</a><br>在参数 <i>str</i> 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr>
				<tr><td>9</td><td><a href="#functionStrcmp" class="n-text-line green">int strcmp(const char *str1, const char *str2)</a><br>把 <i>str1</i> 所指向的字符串和 <i>str2</i> 所指向的字符串进行比较。</td></tr>
				<tr><td>10</td><td><a href="#functionStrncmp" class="n-text-line green">int strncmp(const char *str1, const char *str2, size_t n)</a><br>把 <i>str1</i> 和 <i>str2</i> 进行比较，最多比较前 n 个字节。</td></tr>
				<tr><td>11</td><td><a href="#functionStrcoll" class="n-text-line green">int strcoll(const char *str1, const char *str2)</a><br>把 <i>str1</i> 和 <i>str2</i> 进行比较，结果取决于 LC_COLLATE 的位置设置。</td></tr>
				<tr><td>12</td><td><a href="#functionStrcpy" class="n-text-line green">char *strcpy(char *dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串复制到 <i>dest</i>。</td></tr>
				<tr><td>13</td><td><a href="#functionStrncpy" class="n-text-line green">char *strncpy(char *dest, const char *src, size_t n)</a><br>把 <i>src</i> 所指向的字符串复制到 <i>dest</i>，最多复制 n 个字符。</td></tr>
				<tr><td>14</td><td><a href="#functionStrcspn" class="n-text-line green">size_t strcspn(const char *str1, const char *str2)</a><br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td></tr>
				<tr><td>15</td><td><a href="#functionStrerror" class="n-text-line green">char *strerror(int errnum)</a><br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td></tr>
				<tr><td>16</td><td><a href="#functionStrlen" class="n-text-line green">size_t strlen(const char *str)</a><br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td></tr>
				<tr><td>17</td><td><a href="#functionStrpbrk" class="n-text-line green">char *strpbrk(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i> 中第一个匹配字符串 <i>str2</i> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td></tr>
				<tr><td>18</td><td><a href="#functionStrrchr" class="n-text-line green">char *strrchr(const char *str, int c)</a><br>在参数 <i>str</i> 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td></tr>
				<tr><td>19</td><td><a href="#functionStrspn" class="n-text-line green">size_t strspn(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i> 中第一个不在字符串 <i>str2</i> 中出现的字符下标。</td></tr>
				<tr><td>20</td><td><a href="#functionStrstr" class="n-text-line green">char *strstr(const char *haystack, const char *needle)</a><br>在字符串 <i>haystack</i> 中查找第一次出现字符串 <i>needle</i>（不包含空结束字符）的位置。</td></tr>
				<tr><td>21</td><td><a href="#functionStrtok" class="n-text-line green">char *strtok(char *str, const char *delim)</a><br>分解字符串 <i>str</i> 为一组字符串，<i>delim</i> 为分隔符。</td></tr>
				<tr><td>22</td><td><a href="#functionStrxfrm" class="n-text-line green">size_t strxfrm(char *dest, const char *src, size_t n)</a><br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 <b>src</b> 的前 <b>n</b> 个字符，并把它们放置在字符串 <b>dest</b> 中。</td></tr>
			</tbody>
		</table>
	</div>
	<div class="n-nav-strip clearfix">
		<a href="#standardLibStdlibH" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			C 标准库 - &lt;stdlib.h&gt;
		</a>
		<a href="#standardLibTimeH" class="pull-right green">
			C 标准库 - &lt;time.h&gt;
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
</div>
