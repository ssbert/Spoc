<div class="collections-html">
	<div class="n-nav-strip clearfix">
		<a href="#dataStructures" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			Java 数据结构
		</a>
		<a href="#generics" class="pull-right green">
			Java 泛型
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
	<div class="n-block n-border-b">
		<h1 class="n-h1">
			Java <span class="green">集合框架</span>
		</h1>
		<p>早在Java 2中之前，Java就提供了特设类。比如：Dictionary, Vector, Stack, 和Properties这些类用来存储和操作对象组。 </p>
		<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用Vector类的方式和使用Properties类的方式有着很大不同。</p>
		<p>集合框架被设计成要满足以下几个目标。</p>
		<ul>
			<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
			<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
			<li>对一个集合的扩展和适应必须是简单的。</li>
		</ul>
		<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet等,除此之外你也可以通过这些接口实现自己的集合。</p>
		<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
		<ul>
			<li><strong>接口：</strong>是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。</li>
			<li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。</li>
			<li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
		</ul>
		<p>除了集合，该框架也定义了几个Map接口和类。Map里存储的是键/值对。尽管Map不是collections，但是它们完全整合在集合中。</p>
		<h2 class="n-h2">集合框架体系如图所示</h2>
		<p>
			<img src="/Content/java/images/java-coll.png">
		</p>
		<p>Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">集合接口</h2>
		<p>集合框架定义了一些接口。本节提供了每个接口的概述：</p>
		<table>
			<tbody>
				<tr>
					<th width="10%">序号</th>
					<th>接口描述</th>
				</tr>
				<tr>
					<td>1</td>
					<td>Collection 接口<br><p>
					Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。</p></td>
				</tr>
				<tr>
					<td>2</td>
					<td> List 接口<br><p>
					List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。</p></td>
				</tr>
				<tr>
					<td>3</td>
					<td> Set<br>
						<p>
						Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。</p></td>
					</tr>
					<tr>
						<td>4</td>
						<td> SortedSet<br>

						继承于Set保存有序的集合。</td>
					</tr>
					<tr>
						<td>5</td>
						<td> Map<br>

						将唯一的键映射到值。</td>
					</tr>
					<tr>
						<td>6</td>
						<td> Map.Entry<br>

						描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td>
					</tr>
					<tr>
						<td>7</td>
						<td> SortedMap<br>

						继承于Map，使Key保持在升序排列。</td>
					</tr>
					<tr>
						<td>8</td>
						<td> Enumeration<br>

						这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
					</tr>
				</tbody>
			</table>
		<h3 class="n-h3">Set和List的区别</h3>
		<ul>
			<li><p>1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</p></li>
			<li><p>2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <strong>&lt;实现类有HashSet,TreeSet&gt;</strong>。</p></li>
			<li><p>3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</p></li>
		</ul>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">集合实现类（集合类）</h2>
		<p>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 </p>
		<p>标准集合类汇总于下表：</p>
		<table>
			<tbody>
				<tr>
					<th width="10%">序号</th>
					<th>类描述</th>
				</tr>
				<tr>
					<td>1</td>
					<td><strong>AbstractCollection&nbsp;</strong><br>

					实现了大部分的集合接口。</td>
				</tr>
				<tr>
					<td>2</td>
					<td><strong>AbstractList&nbsp;</strong><br>

					继承于AbstractCollection 并且实现了大部分List接口。</td>
				</tr>
				<tr>
					<td>3</td>
					<td><strong>AbstractSequentialList&nbsp;</strong><br>

					继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</td>
				</tr>
				<tr>
					<td>4</td>
					<td>LinkedList<br>
						<p>
							该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：  
						</p>
						<pre class="prettyprint prettyprinted" style=""><span class="typ">Listlist</span><span class="pun">=</span><span class="typ">Collections</span><span class="pun">.</span><span class="pln">synchronizedList</span><span class="pun">(</span><span class="pln">newLinkedList</span><span class="pun">(...));</span></pre>
						<p>LinkedList 查找效率低。</p>
					</td>
				</tr>
				<tr>
					<td>5</td>
					<td>ArrayList<br>
						<p>
							该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。
						</p></td>
				</tr>
				<tr>
					<td>6</td>
					<td><strong>AbstractSet&nbsp;</strong><br>

					继承于AbstractCollection 并且实现了大部分Set接口。</td>
				</tr>
				<tr>
					<td>7</td>
					<td>HashSet<br><p>
					该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</p></td>
				</tr>
				<tr>
					<td>8</td>
					<td>LinkedHashSet<br>

						具有可预知迭代顺序的&nbsp;<tt>Set</tt>&nbsp;接口的哈希表和链接列表实现。</td>
				</tr>
				<tr>
					<td>9</td>
					<td>TreeSet<br>
						<p>该类实现了Set接口，可以实现排序等功能。</p></td>
				</tr>
				<tr>
					<td>10</td>
					<td><strong>AbstractMap&nbsp;</strong><br>

					实现了大部分的Map接口。</td>
				</tr>
				<tr>
					<td>11</td>
					<td>HashMap
						<br>
						HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>

						该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。
					</td>
				</tr>
				<tr>
					<td>12</td>
					<td>TreeMap
						<br>
					继承了AbstractMap，并且使用一颗树。</td>
				</tr>
				<tr>
					<td>13</td>
					<td>WeakHashMap
						<br>
					继承AbstractMap类，使用弱密钥的哈希表。</td>
				</tr>
				<tr>
					<td>14</td>
					<td>LinkedHashMap
						<br>
					继承于HashMap，使用元素的自然顺序对元素进行排序.</td>
				</tr>
				<tr>
					<td>15</td>
					<td>IdentityHashMap
						<br>
					继承AbstractMap类，比较文档时使用引用相等。</td>
				</tr>
			</tbody>
		</table>
		<p>在前面的教程中已经讨论通过java.util包中定义的类，如下所示： </p>
		<table>
			<tbody>
				<tr>
					<th width="10%">序号</th>
					<th>类描述</th>
				</tr>
				<tr>
					<td>1</td>
					<td>Vector
						<br>
						<p>该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</p>
					</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Stack
						<br>
					栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Dictionary
						<br>
					Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td>
				</tr>
				<tr>
					<td>4</td>
					<td>Hashtable
						<br><p>
						Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</p></td>
				</tr>
				<tr>
					<td>5</td>
					<td>Properties
						<br>
					Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td>
				</tr>
				<tr>
					<td>6</td>
					<td>BitSet<br>
					一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td>
				</tr>
			</tbody>
		</table>
		<p>一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 </p>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">集合算法</h2>
		<p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p>
		<p>在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。</p>
		<p>集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。</p>
		<table>
			<tbody>
				<tr>
					<th width="10%">
					序号</th>
					<th>
					算法描述</th>
				</tr>
				<tr>
					<td>
					1</td>
					<td>
						Collection Algorithms<br>
					这里是一个列表中的所有算法实现。</td>
				</tr>
			</tbody>
		</table>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">如何使用迭代器 </h2>
		<p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p>
		<p>一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。</p>
		<p>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。</p>
		<table>
			<tbody>
				<tr>
					<th width="10%">
					序号</th>
					<th>
					迭代器方法描述</th>
				</tr>
				<tr>
					<td>
					1</td>
					<td>
						使用 Java Iterator<br>
						<span id="result_box" tabindex="-1">这里通过</span>实例列出Iterator和listIterator接口提供的所有方法。</td>
				</tr>
			</tbody>
		</table>
		<h3 class="n-h3">遍历 ArrayList</h3>
		<div class="n-example">
			<h2 class="n-example-h2 green">实例</h2>
			<pre><code>import java.util.*;
 
public class Test{
 public static void main(String[] args) {
     List&lt;String&gt; list=new ArrayList&lt;String&gt;();
     list.add("Hello");
     list.add("World");
     list.add("HAHAHAHA");
     //第一种遍历方法使用foreach遍历List
     for (String str : list) {            //也可以改写for(int i=0;i < list.size();i++)这种形式
        System.out.println(str);
     }
 
     //第二种遍历，把链表变为数组相关的内容进行遍历
     String[] strArray=new String[list.size()];
     list.toArray(strArray);
     for(int i=0;i < strArray.length;i++) //这里也可以改写为  foreach(String str:strArray)这种形式
     {
        System.out.println(strArray[i]);
     }
     
    //第三种遍历 使用迭代器进行相关遍历
     
     Iterator&lt;String&gt; ite=list.iterator();
     while(ite.hasNext())//判断下一个元素之后有值
     {
         System.out.println(ite.next());
     }
 }
}</code></pre>
		</div>
		<p><b>解析： </b></p>
		<p>三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 </p>
		<h3 class="n-h3">遍历 Map</h3>
		<div class="n-example">
			<h2 class="n-example-h2 green">实例</h2>
			<pre><code>import java.util.*;
 
public class Test{
     public static void main(String[] args) {
      Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
      map.put("1", "value1");
      map.put("2", "value2");
      map.put("3", "value3");
      
      //第一种：普遍使用，二次取值
      System.out.println("通过Map.keySet遍历key和value：");
      for (String key : map.keySet()) {
       System.out.println("key= "+ key + " and value= " + map.get(key));
      }
      
      //第二种
      System.out.println("通过Map.entrySet使用iterator遍历key和value：");
      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();
      while (it.hasNext()) {
       Map.Entry&lt;String, String&gt; entry = it.next();
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
      
      //第三种：推荐，尤其是容量大时
      System.out.println("通过Map.entrySet遍历key和value");
      for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
    
      //第四种
      System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
      for (String v : map.values()) {
       System.out.println("value= " + v);
      }
     }
}</code></pre>
		</div>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">如何使用比较器 </h2>
		<p>TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序。</p>
		<p>这个接口可以让我们以不同的方式来排序一个集合。</p>
		<table>
			<tbody>
				<tr>
					<th width="10%">
					序号</th>
					<th>
					比较器方法描述</th>
				</tr>
				<tr>
					<td>
					1</td>
					<td>
						使用 Java Comparator<br>
					这里通过实例列出Comparator接口提供的所有方法</td>
				</tr>
			</tbody>
		</table>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">总结</h2>
		<p>Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。</p>
		<p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p>
		<p>集合框架的类和接口均在java.util包中。</p>
		<p>任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。</p>
	</div>
	<div class="n-nav-strip clearfix">
		<a href="#dataStructures" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			Java 数据结构
		</a>
		<a href="#generics" class="pull-right green">
			Java 泛型
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
</div>	