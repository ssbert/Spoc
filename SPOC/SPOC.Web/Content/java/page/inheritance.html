<div class="inheritance-block">
	<div class="n-nav-strip clearfix">
		<a href="#exceptions" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			Java 异常处理
		</a>
		<a href="#overrideOverload" class="pull-right green">																																						
			Java 重写(Override)与重载(Overload)
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
	<div class="n-block n-border-b">
		<h1 class="n-h1">
			Java <span class="green">继承</span>
		</h1>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">继承的概念</h2>
		<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
		<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 </p>
		<h3 class="n-h3">生活中的继承： </h3>
		<p>
			<img src="/Content/java/images/14B0951E-FC75-47A3-B611-4E1883887339.jpg">
		</p>
		<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
		<p>食草动物和食肉动物又是属于动物类。</p>
		<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
		<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
		<h3 class="n-h3">类的继承格式</h3>
		<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
		<div class="n-example">
			<h2 class="n-example-h2 green">类的继承格式</h2>
			<pre><code>class 父类 {
}
 
class 子类 extends 父类 {
}</code></pre>
		</div>
		<h3 class="n-h3">为什么需要继承 </h3>
		<p>接下来我们通过实例来说明这个需求。</p>
		<p>开发动物类，其中动物分别为企鹅以及老鼠，要求如下：</p>
		<ul>
			<li>企鹅：属性（姓名，id），方法（吃，睡，自我介绍）</li>
			<li>老鼠：属性（姓名，id），方法（吃，睡，自我介绍）</li>
		</ul>
		<div class="n-example">
			<h2 class="n-example-h2 green">企鹅类：</h2>
			<pre><code>public class Penguin { 
    private String name; 
    private int id; 
    public Penguin(String myName, int  myid) { 
        name = myName; 
        id = myid; 
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"         + id + "号" + name + "."); 
    } 
}</code></pre>
		</div>
		<div class="n-example">
			<h2 class="n-example-h2 green">老鼠类：</h2>
			<pre><code>public class Mouse { 
    private String name; 
    private int id; 
    public Mouse(String myName, int  myid) { 
        name = myName; 
        id = myid; 
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"         + id + "号" + name + "."); 
    } 
}</code></pre>
		</div>
		<p>从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类：</p>
		<div class="n-example">
			<h2 class="n-example-h2">公共父类：</h2>
			<pre><code>public class Animal { 
    private String name;  
    private int id; 
    public Animal(String myName, int myid) { 
        name = myName; 
        id = myid;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"         + id + "号" + name + "."); 
    } 
}</code></pre>
		</div>
		<p>这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：</p>
		<div class="n-example">
			<h2 class="n-example-h2 green">
				企鹅类：
			</h2>
			<pre><code>public class Penguin extends Animal { 
    public Penguin(String myName, int myid) { 
        super(myName, myid); 
    } 
}</code></pre>
		</div>
		<div class="n-example">
			<h2 class="n-example-h2 green">老鼠类：</h2>
			<pre><code>public class Mouse extends Animal { 
    public Mouse(String myName, int myid) { 
        super(myName, myid); 
    } 
}</code></pre>
		</div>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">继承的特性</h2>
		<ul>
			<li><p>子类拥有父类非private的属性，方法。</p></li>
			<li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li>
			<li><p>子类可以用自己的方式实现父类的方法。</p></li>
			<li><p>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</p></li>
			<li><p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p></li>
		</ul>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">
			继承关键字
		</h2>
		<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <b>java.lang</b> 包中，所以不需要 <b>import</b>）祖先类。</p>
		<h3 class="n-h3">extends关键字</h3>
		<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
		<div class="n-example">
			<h2 class="n-example-h2 green">extends 关键字</h2>
			<pre><code>public class Animal { 
    private String name;   
    private int id; 
    public Animal(String myName, String myid) { 
        //初始化属性值
    } 
    public void eat() {  //吃东西方法的具体实现  } 
    public void sleep() { //睡觉方法的具体实现  } 
} 
 
public class Penguin  extends  Animal{ 
}</code></pre>
		</div>
		<h3 class="n-h3">implements关键字</h3>
		<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
		<div class="n-example">
			<h2 class="n-example-h2 green">implements 关键字</h2>
			<pre><code>public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
public class C implements A,B {
}</code></pre>
		</div>
		<h3 class="n-h3">
			super 与 this 关键字
		</h3>
		<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
		<p>this关键字：指向自己的引用。</p>
		<div class="n-example">
			<h2 class="n-example-h2 green">实例</h2>
			<pre><code>class Animal {
  void eat() {
    System.out.println("animal : eat");
  }
}
 
class Dog extends Animal {
  void eat() {
    System.out.println("dog : eat");
  }
  void eatTest() {
    this.eat();   // this 调用自己的方法
    super.eat();  // super 调用父类方法
  }
}
 
public class Test {
  public static void main(String[] args) {
    Animal a = new Animal();
    a.eat();
    Dog d = new Dog();
    d.eatTest();
  }
}</code></pre>
		</div>
		<p>输出结果为：</p>
		<pre>animal : eat
dog : eat
animal : eat</pre>
		<h3 class="n-h3">final关键字</h3>
		<p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>
		<ul>
			<li>
				<p>声明类：</p>
				<pre>final class 类名 {//类体}</pre>
			</li>
			<li>
				<p>声明方法：</p>
				<pre>修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}</pre>
			</li>
		</ul>
		<p><b>注:</b>实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p>
	</div>
	<div class="n-block n-border-b">
		<h2 class="n-h2">构造器</h2>
		<p>子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。</p>
		<p>如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。 </p>
		<div class="n-example">
			<h2 class="n-example-h2 green">
				实例
			</h2>
			<pre><code>class SuperClass {
  private int n;
  SuperClass(){
    System.out.println("SuperClass()");
  }
  SuperClass(int n) {
    System.out.println("SuperClass(int n)");
    this.n = n;
  }
}
class SubClass extends SuperClass{
  private int n;
  
  SubClass(){
    super(300);
    System.out.println("SubClass");
  }  
  
  public SubClass(int n){
    System.out.println("SubClass(int n):"+n);
    this.n = n;
  }
}
public class TestSuperSub{
  public static void main (String args[]){
    SubClass sc = new SubClass();
    SubClass sc2 = new SubClass(200); 
  }
}</code></pre>
		</div>
		<p>输出结果为：</p>
		<pre><code>SuperClass(int n)
SubClass
SuperClass()
SubClass(int n):200</code></pre>
	</div>
	<div class="n-nav-strip clearfix">
		<a href="#exceptions" class="pull-left green">
			<span class="glyphicon glyphicon-arrow-left gray"></span>
			Java 异常处理
		</a>
		<a href="#overrideOverload" class="pull-right green">																																						
			Java 重写(Override)与重载(Overload)
			<span class="glyphicon glyphicon-arrow-right gray"></span>
		</a>
	</div>
</div>
